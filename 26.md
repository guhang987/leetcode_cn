---
title: 26. 删除排序数组中的重复项
date: 2019-1-20
tags: 双指针
---
# 26. 删除排序数组中的重复项
## 题目
> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
## 思路1
1112236789<br>
一开始想的是p和q作为前两个指针，找到目标位置后就把后面的一大串全往前移动。发现有重复，就把p和q作为最后俩指针再看。总之是移动全部串，写出来发现代码笨重不易读，还有bug。第二天再仔细读题，发现“有序数组”这个条件没用，于是重新想。<br>
后来发现重排后必定是1234这样子的，每次只需要移动一个数字。比如开始p指向1，q指向第二个1，q移到目标位置2，p++，**让a[p]=a[q]就可以了**。然后回到循环开始，因为p指向2了，q也是2，这样q就会往后移到3。
``` c
int removeDuplicates(vector<int>& nums) {
	if (nums.size() <= 1) return nums.size();
	int p = 0, q = 1;
	while (1) {
		if (nums[p] != nums[q]) {
			p++, q++;
            if (q == nums.size()) return p + 1;
		}
		else{
			do {
				q++;
				if (q == nums.size()) return p + 1;
			} while (nums[p] == nums[q]);
			nums[++p] = nums[q];
		}
	}
}
```

|时间复杂度| 空间复杂度|运行时间| 排名
|-|-|-|-
|O(n)|O(1)|20ms|98%

## 优化思路
top1的答案思路和我一样，就是代码简洁，但是可读性稍微弱一点。

```c
int removeDuplicates(vector<int>& nums)
    {
        if(nums.empty())
            return 0;
        int i=0，j=1，len =nums.size();
        for(;j<len;j++){
           if(nums[i]!=nums[j]) nums[++i]=nums[j];
        }
        return (i+1);   
    }

```
|时间复杂度| 空间复杂度|运行时间| 排名
|-|-|-|-
|O(n)|O(1)|16ms|100%
## 总结
一开始，我总想着先找目标位置，再移动后面一大堆。如果是无序数组可以这样，但是我有序就可以利用这个条件了。然后要注意出现异常情况，比如q++,q可能移到队列外了，要加上判断语句来管控。
